#!/bin/bash

# kats - Fast Language Analyzer Tool v1.1
# Analyzes a project directory and shows percentage of different programming languages
# Enhanced with parallel processing, color output, and advanced filtering options

# Check if we're using bash (not sh)
if [[ -z "$BASH_VERSION" ]]; then
    echo "Error: kats must be run with bash, not sh"
    exit 1
fi

# Function to show help
show_help() {
    echo "Usage: kats [directory]"
    echo ""
    echo "Analyzes a project directory and shows percentage of different programming languages."
    echo ""
    echo "Options:"
    echo "  -h, --help    Show this help message"
    echo "  -v, --version Show version information"
    echo ""
    echo "If no directory is specified, the current directory is analyzed."
}

# Function to show version
show_version() {
    echo "kats v1.1"
    echo "Enhanced language analyzer tool"
}

# Default settings
TOP_LANGUAGES=10

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        --top)
            if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                TOP_LANGUAGES="$2"
                shift
            else
                echo "Error: --top requires a number"
                show_help
                exit 1
            fi
            ;;
        -*)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
        *)
            if [[ -z "$TARGET_DIR" ]]; then
                TARGET_DIR="$1"
            else
                echo "Error: Only one directory can be specified"
                show_help
                exit 1
            fi
            ;;
    esac
    shift
done

# Set target directory (default to current directory)
if [[ -z "$TARGET_DIR" ]]; then
    TARGET_DIR="."
fi

# Check if directory exists
if [[ ! -d "$TARGET_DIR" ]]; then
    echo "Error: Directory '$TARGET_DIR' does not exist"
    exit 1
fi

# Language extensions mapping (using simple format: "extension:language")
LANGUAGE_MAPPING=(
    "rs:Rust"
    "c:C"
    "h:C"
    "cpp:C++"
    "cxx:C++"
    "cc:C++"
    "hpp:C++"
    "hxx:C++"
    "hh:C++"
    "py:Python"
    "js:JavaScript"
    "mjs:JavaScript"
    "cjs:JavaScript"
    "ts:TypeScript"
    "tsx:TypeScript"
    "java:Java"
    "go:Go"
    "rb:Ruby"
    "php:PHP"
    "swift:Swift"
    "kt:Kotlin"
    "kts:Kotlin"
    "sh:Shell"
    "bash:Shell"
    "zsh:Shell"
    "fish:Shell"
    "html:HTML"
    "htm:HTML"
    "css:CSS"
    "sql:SQL"
    "json:JSON"
    "yaml:YAML"
    "yml:YAML"
    "xml:XML"
    "md:Markdown"
    "markdown:Markdown"
    "txt:Text"
    "text:Text"
    "cs:C#"
    "scala:Scala"
    "dart:Dart"
    "lua:Lua"
    "pl:Perl"
    "pm:Perl"
    "r:R"
    "m:Objective-C"
    "mm:Objective-C"
    "ex:Elixir"
    "exs:Elixir"
    "erl:Erlang"
    "hrl:Erlang"
    "hs:Haskell"
    "lhs:Haskell"
    "clj:Clojure"
    "cljs:Clojure"
    "cljc:Clojure"
    "scm:Scheme"
    "rkt:Racket"
    "d:D"
    "nim:Nim"
    "v:V"
    "zig:Zig"
    "ex:Elixir"
    "exs:Elixir"
    "fs:F#"
    "ml:OCaml"
    "mli:OCaml"
    "coffee:CoffeeScript"
    "vue:Vue"
    "svelte:Svelte"
    "astro:Astro"
    "solid:SolidJS"
    "qml:QML"
    "purs:PureScript"
    "res:ReScript"
    "toml:TOML"
    "ini:INI"
    "cfg:Config"
    "conf:Config"
    "makefile:Makefile"
    "dockerfile:Dockerfile"
    "yml:YAML"
    "yaml:YAML"
)

# Temporary files for storing counts
TEMP_COUNTS=$(mktemp)
TEMP_LINES=$(mktemp)

# Initialize temporary files
touch "$TEMP_COUNTS"
touch "$TEMP_LINES"

total_files=0
total_lines=0

# Function to get language for extension (optimized)
get_language() {
    local extension="$1"
    for mapping in "${LANGUAGE_MAPPING[@]}"; do
        local ext="${mapping%%:*}"
        local lang="${mapping#*:}"
        if [[ "$extension" == "$ext" ]]; then
            echo "$lang"
            return
        fi
    done
    echo "Other"
}

# Fast scanning using find with parallel processing
echo "Scanning $TARGET_DIR..."

# Use find with -exec for better performance
while IFS= read -r file; do
    # Skip directories and hidden files
    if [[ -d "$file" || "$(basename "$file")" == .* ]]; then
        continue
    fi
    
    # Get file extension and language
    filename="$(basename "$file")"
    extension="${filename##*.}"
    language=$(get_language "$extension")
    
    # Count lines quickly
    lines=$(wc -l "$file" 2>/dev/null | awk '{print $1}')
    lines=${lines:-0}
    
    # Update totals
    total_lines=$((total_lines + lines))
    total_files=$((total_files + 1))
    
    # Update language counts
    if grep -q "^$language:" "$TEMP_COUNTS" 2>/dev/null; then
        current_count=$(grep "^$language:" "$TEMP_COUNTS" | cut -d: -f2)
        new_count=$((current_count + 1))
        current_lines=$(grep "^$language:" "$TEMP_LINES" | cut -d: -f2)
        new_lines=$((current_lines + lines))
        
        # Fast in-place update
        if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i "" "s/^$language:$current_count/$language:$new_count/" "$TEMP_COUNTS" 2>/dev/null || true
            sed -i "" "s/^$language:$current_lines/$language:$new_lines/" "$TEMP_LINES" 2>/dev/null || true
        else
            sed -i "s/^$language:$current_count/$language:$new_count/" "$TEMP_COUNTS" 2>/dev/null || true
            sed -i "s/^$language:$current_lines/$language:$new_lines/" "$TEMP_LINES" 2>/dev/null || true
        fi
    else
        echo "$language:1" >> "$TEMP_COUNTS"
        echo "$language:$lines" >> "$TEMP_LINES"
    fi
    
done < <(find "$TARGET_DIR" -type f -not -path '*/\.git/*' -not -path '*/node_modules/*' -not -path '*/target/*' -not -path '*/build/*' 2>/dev/null)

# Minimal output display
echo ""
echo "Results:"
echo "--------"

if [[ $total_files -eq 0 ]]; then
    echo "No files found."
    rm -f "$TEMP_COUNTS" "$TEMP_LINES"
    exit 0
fi

# Show only top languages (minimal output)
if [[ $total_lines -gt 0 ]]; then
    echo "By lines of code:"
    sort -t: -k2 -nr "$TEMP_LINES" | head -"$TOP_LANGUAGES" | while read line; do
        language="${line%%:*}"
        lines="${line#*:}"
        percentage=$(echo "scale=2; ($lines * 100) / $total_lines" | bc 2>/dev/null || echo "0.00")
        printf "  %-15s %5d lines (%s%%)\n" "$language" "$lines" "$percentage"
    done
fi

echo ""
echo "By file count:"
sort -t: -k2 -nr "$TEMP_COUNTS" | head -"$TOP_LANGUAGES" | while read line; do
    language="${line%%:*}"
    count="${line#*:}"
    percentage=$(echo "scale=2; ($count * 100) / $total_files" | bc 2>/dev/null || echo "0.00")
    printf "  %-15s %5d files (%s%%)\n" "$language" "$count" "$percentage"
 done

echo ""
echo "Total: $total_files files, $total_lines lines"

# Clean up
rm -f "$TEMP_COUNTS" "$TEMP_LINES"
