#!/bin/bash

# kats - Ultra-Fast Language Analyzer Tool v1.1
# Analyzes a project directory and shows percentage of different programming languages
# Enhanced with parallel processing, color output, and advanced filtering options

# Check if we're using bash (not sh)
if [[ -z "$BASH_VERSION" ]]; then
    echo "Error: kats must be run with bash, not sh"
    exit 1
fi

# Function to show help
show_help() {
    echo "Usage: kats [directory]"
    echo ""
    echo "Analyzes a project directory and shows percentage of different programming languages."
    echo ""
    echo "Options:"
    echo "  -h, --help    Show this help message"
    echo "  -v, --version Show version information"
    echo ""
    echo "If no directory is specified, the current directory is analyzed."
}

# Function to show version
show_version() {
    echo "kats v1.1"
    echo "Enhanced language analyzer with --top option and modern language support"
}

# Default settings
TOP_LANGUAGES=10

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        --top)
            if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                TOP_LANGUAGES="$2"
                shift
            else
                echo "Error: --top requires a number"
                show_help
                exit 1
            fi
            ;;
        -*)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
        *)
            if [[ -z "$TARGET_DIR" ]]; then
                TARGET_DIR="$1"
            else
                echo "Error: Only one directory can be specified"
                show_help
                exit 1
            fi
            ;;
    esac
    shift
done

# Set target directory (default to current directory)
if [[ -z "$TARGET_DIR" ]]; then
    TARGET_DIR="."
fi

# Check if directory exists
if [[ ! -d "$TARGET_DIR" ]]; then
    echo "Error: Directory '$TARGET_DIR' does not exist"
    exit 1
fi

# Language extensions mapping (optimized for speed)
# Format: extension:language
LANGUAGE_MAPPING=(
    "rs:Rust"
    "c:C"
    "h:C"
    "cpp:C++"
    "cxx:C++"
    "cc:C++"
    "hpp:C++"
    "hxx:C++"
    "hh:C++"
    "py:Python"
    "js:JavaScript"
    "mjs:JavaScript"
    "cjs:JavaScript"
    "ts:TypeScript"
    "tsx:TypeScript"
    "java:Java"
    "go:Go"
    "rb:Ruby"
    "php:PHP"
    "swift:Swift"
    "kt:Kotlin"
    "kts:Kotlin"
    "sh:Shell"
    "bash:Shell"
    "zsh:Shell"
    "fish:Shell"
    "html:HTML"
    "htm:HTML"
    "css:CSS"
    "sql:SQL"
    "json:JSON"
    "yaml:YAML"
    "yml:YAML"
    "xml:XML"
    "md:Markdown"
    "markdown:Markdown"
    "txt:Text"
    "text:Text"
    "cs:C#"
    "cshtml:C#"
    "razor:C#"
    "scala:Scala"
    "dart:Dart"
    "lua:Lua"
    "pl:Perl"
    "pm:Perl"
    "r:R"
    "m:Objective-C"
    "mm:Objective-C"
    "ex:Elixir"
    "exs:Elixir"
    "erl:Erlang"
    "hrl:Erlang"
    "hs:Haskell"
    "lhs:Haskell"
    "clj:Clojure"
    "cljs:Clojure"
    "cljc:Clojure"
    "scm:Scheme"
    "rkt:Racket"
    "d:D"
    "nim:Nim"
    "v:V"
    "zig:Zig"
    "fs:F#"
    "ml:OCaml"
    "mli:OCaml"
    "coffee:CoffeeScript"
    "vue:Vue"
    "svelte:Svelte"
    "astro:Astro"
    "solid:SolidJS"
    "qml:QML"
    "purs:PureScript"
    "res:ReScript"
    "toml:TOML"
    "ini:INI"
    "cfg:Config"
    "conf:Config"
    "makefile:Makefile"
    "dockerfile:Dockerfile"
    "sln:Solution"
    "csproj:C# Project"
    "vb:Visual Basic"
    "vbs:VBScript"
    "ps1:PowerShell"
    "psm1:PowerShell"
    "psd1:PowerShell"
    "bat:Batch"
    "cmd:Batch"
    "asm:Assembly"
    "s:Assembly"

    "xaml:XAML"
    "axaml:XAML"

    "gradle:Gradle"
    "groovy:Groovy"
    "gvy:Groovy"
    "gy:Groovy"
    "gsp:Groovy"

)

# Fast scanning using find with direct processing
echo "Scanning $TARGET_DIR..."

# Use temporary files for ultra-fast counting (compatible with all bash versions)
TEMP_COUNTS=$(mktemp)
TEMP_LINES=$(mktemp)
TEMP_FILES=$(mktemp)
TEMP_TOTAL_LINES=$(mktemp)
trap "rm -f $TEMP_COUNTS $TEMP_LINES $TEMP_FILES $TEMP_TOTAL_LINES" EXIT

# Function to get language for extension (ultra-optimized)
get_language() {
    local extension="$1"
    for mapping in "${LANGUAGE_MAPPING[@]}"; do
        local ext="${mapping%%:*}"
        local lang="${mapping#*:}"
        if [[ "$extension" == "$ext" ]]; then
            echo "$lang"
            return
        fi
    done
    echo "Other"
}

# Process files with maximum speed using process substitution to avoid subshell issues
while IFS= read -r -d '' file; do
    # Get file extension and language
    filename="$(basename "$file")"
    extension="${filename##*.}"
    language=$(get_language "$extension")
    
    # Count lines with maximum efficiency
    lines=$(wc -l "$file" 2>/dev/null | awk '{print $1}')
    lines=${lines:-0}
    
    # Store data in temporary files to avoid subshell variable issues
    echo "$file" >> "$TEMP_FILES"
    echo "$lines" >> "$TEMP_TOTAL_LINES"
    
    # Fast counting using temporary files
    if grep -q "^$language:" "$TEMP_COUNTS" 2>/dev/null; then
        current_count=$(grep "^$language:" "$TEMP_COUNTS" | cut -d: -f2)
        new_count=$((current_count + 1))
        current_lines=$(grep "^$language:" "$TEMP_LINES" | cut -d: -f2)
        new_lines=$((current_lines + lines))
        
        # Fast in-place update
        if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i "" "s/^$language:$current_count/$language:$new_count/" "$TEMP_COUNTS" 2>/dev/null || true
            sed -i "" "s/^$language:$current_lines/$language:$new_lines/" "$TEMP_LINES" 2>/dev/null || true
        else
            sed -i "s/^$language:$current_count/$language:$new_count/" "$TEMP_COUNTS" 2>/dev/null || true
            sed -i "s/^$language:$current_lines/$language:$new_lines/" "$TEMP_LINES" 2>/dev/null || true
        fi
    else
        echo "$language:1" >> "$TEMP_COUNTS"
        echo "$language:$lines" >> "$TEMP_LINES"
    fi
    
done < <(find "$TARGET_DIR" -type f \
    -not -path '*/\.git/*' \
    -not -path '*/node_modules/*' \
    -not -path '*/target/*' \
    -not -path '*/build/*' \
    -not -name '.*' \
    -print0 2>/dev/null)

# Calculate totals from temporary files
total_files=$(wc -l "$TEMP_FILES" 2>/dev/null | awk '{print $1}')
total_lines=$(awk '{sum+=$1} END {print sum}' "$TEMP_TOTAL_LINES" 2>/dev/null || echo "0")

# Display results with minimal overhead
echo ""
echo "Results:"
echo "--------"

if [[ $total_files -eq 0 ]]; then
    echo "No files found."
    exit 0
fi

# Show top languages by lines of code
echo "By lines of code:"
sort -t: -k2 -nr "$TEMP_LINES" | head -"$TOP_LANGUAGES" | while read line; do
    language="${line%%:*}"
    lines="${line#*:}"
    percentage=$(awk "BEGIN {printf \"%.2f\", ($lines * 100) / $total_lines}")
    printf "  %-15s %5d lines (%s%%)
" "$language" "$lines" "$percentage"
done

echo ""
echo "By file count:"
sort -t: -k2 -nr "$TEMP_COUNTS" | head -"$TOP_LANGUAGES" | while read line; do
    language="${line%%:*}"
    count="${line#*:}"
    percentage=$(awk "BEGIN {printf \"%.2f\", ($count * 100) / $total_files}")
    printf "  %-15s %5d files (%s%%)
" "$language" "$count" "$percentage"
done

echo ""
echo "Total: $total_files files, $total_lines lines"